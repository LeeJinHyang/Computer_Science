## **객체 지향 프로그래밍**

​    

**객체지향 프로그래밍 이란****? (Object - Oriented Programming)**

객체 지향 프로그래밍은 프로그래밍 패러다임중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 시스템을 구성하는 프로그래밍 방법이다.

​    

**객체지향 프로그래밍의 장점****/****단점**

​    

**장점**

코드 재사용 용이

\- 남이 만든 객체를 가져와서 이용할 수 있고, 상속을 통해 확장해서 사용 가능

​    

유지보수 쉬움

\- 객체지향 프로그래밍 에서는 수정해야할 부분이 클래스 내부에 멤버 변수 혹은 메서드로 존재하기 때문에 수정에 용이

​    

대형 프로젝트에 적함

\- 객체단위로 모듈화시켜서 개발할 수 있어서, 여러명이 투입되는 대형프로젝트에서 업무분담에 용이

​    

강한 응집력과 약한 결합력을 가진다.

\- 응집력

-> 프로그램의 한 요소가 해당 기능을 수행하기 위해 얼마만큼의 연관된 책임과 역할을 뭉쳐있는지를 나타내는 정도를 의미

-> 프로그램의 한 요소가 특정 목적을 위해 밀접하게 연관된 기능들이 모여서 구현되어 있고, 지나치게 많은 일을 하지 않으면 응집력이 높다

-결합력

-> 프로그램 코드의 한 요소가 다른 것과 얼마나 강력하게 연결되어 있는지, 얼마나 의존적인지를 나타내는 정도

-> 결합력이 낮다는 것은 한 요소가 다른 요소들과 관계를 크게 맺고 있지 않는 상태를 의미한다.

​    

**단점**

\- 객체들간의 통신하는 오버헤드로 인해서 처리속도가 상대적으로 느림

\- 객체가 많으면 용량이 커진다

\- 설계시 많은 시간든다

​    

​    

​    

​    

**객체지향 프로그래밍 구성 요소**

**객체**

\- 객체는 데이터와 데이터를 처리하는 메서드를 묶어놓은 모듈이다.

\- 객체지향 프로그래밍의 산출물은 "클래스"가 아니라 "객체"이다.

\- "객체"를 분리하기 위해 클래스가 등장한것 이다.

\- 객체지향 설계에서 중요한 것은 어떤 클래스가 필요한가가 아니라 어떤 객체들이 어떤 메시지를 주고받으며 협력하는가이다.

\- 메시지를 주고받는 객체의 관점으로 애플리케이션을 바라봐야한다.

​    

**SOLID** **원칙**

​    

**SRP (Single Responsibilty Principle)**

" 한 클래스는 단 한가지 역할을 가져야 한다."

​    

SRP는 클래스는 한 가지 일만 하라는 원칙이다.

한가지 일은 책임 혹은 역할 이라고 불린다.

\- 역할은 클래스, 책임은 메소드

ReplyReviewController, PhotoThumbnailGenerator은 한가지 일을 하는 클래스이다. 하지만, ReviewController를 만들어서 리뷰를 쓰고,지우고,수정하는 것을 한 클래스에서 구현한것은 SRP에 위배

DB에 고객정보를 저장하고, 관리자에게 등록된 신규정보를 sms로 알려주는 클래스?

\- 신규정보 sms알려주는 기능을 다른 클래스에 delegate(위임)하면 SRP위배되지 않음

​    

**OCP (Open-Closed Principle)**

\- 사용중인 코드를 변경하는 것이 아니라, 새로운 코드를 덧붙여서 기능을 확장

\- 확장에 열려 있어야하고, 수정에는 닫혀 있어야한다.

\- 하위모듈의 기능이 확장될 경우 기존 클래스를 수정하는 것이 아니라 새로운 클래스를 추가해서 기능을 추가하라

​    

**LSP (Liskob Substitution Principle)**

\- 자식 타입은 부모 타입으로 치환 가능해야 한다.

\- 상속관계에서, 자식 타입은 부모 타입으로 치환 가능해야 한다.

\- 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위타입을 사용하는 프로그램은 정상적으로 동작해야 한다.

사각형,정사각형 예제

​    

​    

​    

**ISP (Interface Segregation Principle)**

\- 클라이언트가 자신이 사용하지 않는 메서드에 의존하지 않아야 한다.

\- 클라이언트가 자신이 사용하지 않는 메서드에 의존하도록 되면, 클라이언트는 이 메서드의 변경에 취약함

​    

**DIP (Dependency Inversion Principle)**

\- 추상화를 통해서 의존 관계를 느슨하게 한다는 원칙

\- 상위,하위 모듈 모두가 동일한 추상화에 의존해야 한다.

\- 상위 모듈이 하위 모듈을 참조할 때 구현클래스를 직접 사용하는 것이 아니라 interface를 참조해야 한다.

​    

**SOLID** **정리**

\- 단일 책임 원칙, 인터페이스 분리 원칙은 객체가 커지지 않도록 막아준다. 객체가 많은 기능을 가지게 되면, 객체가 가진 기능의 변경이 해당 객체의 다른기능에까지 번지게 되고, 이를 사용하는 다른 클래스까지 영향을 준다.

-> 객체가 단일 책임을 갖게 하고 클라이언트 마다 다른 인터페이스를 사용하게 함으로서 한 기능의 변경이 다른 곳까지 미치는 영향을 최소화 시켜줌

\- 리스코프 치환원칙, 의존 역전 원칙은 개방 폐쇄 원칙을 지원한다. 개방 폐쇄 원칙은 변화되는 부분을 추상화하고 다형성을 이용함으로써 기능 확장을 하면서 기존 코드를 수정하지 않도록 만들어 준다.

-> 변화되는 부분을 추상화할 수 있도록 하는 원칙이 의존석 역전 원칙

->다형성을 도와주는 원칙이 리스코프 치환원칙 이다.

\- SOLID원칙은 사용자 입장에서의 기능 사용을 중시한다.

-> 인터페이스 분리 원칙은 클라이언트 입장에서 인터페이스를 분리하고 있다

->의존 역전 원칙 역시 저 수준 모듈을 사용하고 고수준 모듈입장에서 추상화 타입을 도축하도록 유도

-> 리스코프 치환 원칙은 사용자에게 기능 명세를 제공하고, 그 명세에 따라 기능을 구현할 것을 약속한다.