**Array & LinkedList**

우선 자료구조의 기본이라고 할 수 있는 Array 에 대해서 보자. Array는 논리적 순서와 물리적 순서가 일치한다. 따라서 index값을 통한 원소 접근이 용이하며, 구현이 쉽다. 단점으로는 삽입, 삭제 등에 대한 연산에 필요한 Cost가 높다는 것이다. 삭제의 경우 순서를 맞추기 위해, 뒤의 원소들을 모두 앞으로 Shift연산을 해줘야 하며, 삽입의 경우도 삽입한 인덱스 포함, 그 뒤의 인덱스들에 Shift 연산을 해줘야 한다.



![image-20200927230634156](/Users/jh/Library/Application Support/typora-user-images/image-20200927230634156.png)







배열의 삽입/삭제 연산에 대한 비효율성을 극복하고자 등장한 것이 LinkedList 이다. Array와 LinkedList의 차이점은, Array는 논리적, 물리적 저장이 순서대로 되어있으나, LinkedList는 논리적으론 순서대로 되어있으나 물리적으론 순서대로 되어있지 않다. 대신 LinkedList는 각 원소가 다음 index 위치에 해당하는 물리적 주소를 가지고 있다. 그렇기에 삽입/삭제시에는 데이터를 Shift할 필요 없이, 해당되는 원소의 물리적 주소만 변경해주면 된다. 하지만 이 같은 특징 때문에 원하는 index를 참조하려면, 1번 index부터 차례대로 접근해야 한다는 비효율성이 있다.

![image-20200927230642796](/Users/jh/Library/Application Support/typora-user-images/image-20200927230642796.png)









**Stack & Queue**

Stack 은 선형 자료구조의 일종으로, FILO(First In Last Out)의 대표적인 예시로 들 수 있으며, 말 그대로 먼저 들어갔다가 나중에 나오는 구조이다. 즉 가장 나중에 들어간 원소가 가장 먼저 나오게 된다. 미로찾기, 괄호 유효성 체크 등에 활용된다.





![image-20200927230650673](/Users/jh/Library/Application Support/typora-user-images/image-20200927230650673.png)





Queue 역시 선형 자료구조이며, Stack과는 반대로 FIFO(First In First Out) 구조이다. 줄을 선다는 뜻과 같게, 먼저 들어간 원소가 가장 먼저 나온다. 작업 우선순위, Heap 구현 등에 사용된다.





![image-20200927230656619](/Users/jh/Library/Application Support/typora-user-images/image-20200927230656619.png)





**Tree**

Tree 는 Stack, Queue와는 다르게 비선형 자료구조로, 계층적 구조를 표현하는 자료구조이다. 실제 데이터를 삽입하고 삭제한다는 생각 이전에, 표현에 집중하자. 트리의 구성 요소는 다음과 같다.



Node (노드) : 트리를 구성하고 있는 원소 그 자체를 말한다.

Edge (간선) : 노드와 노드사이를 연결하고 있는 선을 말한다.

Root(Node) : 트리에서 최상위 노드를 말한다.

Terminal(Node) : 트리에서 최하위 노드를 말한다. Leaf Node라고도 한다.





Internal(Node) : 트리에서 최하위 노드를 제외한 모든 노드를 말한다.



![image-20200927230704143](/Users/jh/Library/Application Support/typora-user-images/image-20200927230704143.png)

**Binary Tree (이진트리)**

Binary Tree는 Root 노드를 포함, Leaf 노드를 제외한 모든 노드의 자식이 두 개인 것을 말한다. 공집합 역시 노드로 인정한다. 노드로 이루어진 각 층을 Level이라 하며, Level의 수를 이 트리의 height라 한다.



이진트리에는 모든 Level이 가득 찬 이진 트리인 Full Binary Tree(포화 이진 트리) 와 위에서 아래로, 왼쪽에서 오른쪽으로 순서대로 채워진 트리인 Complete Binary Tree(완전 이진 트리) 가 있다(두 트리의 차이점을 알아두면 좋을 것 같다). 배열로 포화 이진트리와 완전 이진트리를 구현했을 때, 노드의 개수 n에 대해서 i번째 노드에 대해서 parent(i) = i/2 , left_child = 2i, right_child = 2i + 1 의 인덱스 값을 갖는다.



![image-20200927230722544](/Users/jh/Library/Application Support/typora-user-images/image-20200927230722544.png)





































**BST, Binary Search Tree (이진 탐색 트리)**

자료구조에서 효율적인 탐색 방법만을 고민할 것이 아니라, 효율적인 저장방법도 고민해야 한다. Binary Search Tree (이진 탐색 트리)는 이진 트리이며, 데이터를 저장하는 특별한 규칙이 있다. 그 규칙으로 찾고자 하는 데이터를 찾을 수 있다.



이진 탐색 노드에 저장된 값은 유일한 값이다.

루트 노드의 값은 왼쪽에 있는 모든 노드의 값보다 크다.

루트 노드의 값은 오른쪽에 있는 모든 노드의 값보다 작다.

각 서브 트리별로 2, 3번 규칙을 만족한다.





저장할 때 위의 규칙대로 잘 저장하기만 하면, 루트 노드로부터 원하는 값을 찾아나가는 것은 어렵지 않을 것이다. 하지만 값이 추가되고 삭제됨에 따라, 한 쪽에만 치우친 Skewed Tree(편향 트리)가 될 가능성이 있다. 이를 해결하기 위해 Rebalancing이라는 기법을 사용하여 트리를 재조정하게 된다.





평균 탐색시간은 O(logN), 최악 탐색시간은 O(N)

![image-20200927230733051](/Users/jh/Library/Application Support/typora-user-images/image-20200927230733051.png)

**트립 ( Treap )**



\- 정의 : 균형 잡힌 이진탐색트리. BST에서 Skewed Tree가 만들어지는 이유는 데이터가 일정한 순서에 의해 입력되는 이유이다. 이때, 각 들어오는 데이터에 대해 랜덤 하게 “우선순위”를 부여함으로써, Heap처럼 우선순위에 따라 삽입한다.

\- 조건

ㆍ부모 노드의 우선순위가 자식 노드의 우선순위보다 커야 한다 ( heap )

ㆍ부모 노드의 왼쪽 자식 노드는 더 작은 key, 오른쪽 자식 노드는 더 큰 key값을 가진다 ( BST )

\- 삽입 / 삭제 알고리즘은 기존 BST보다 조금 복잡하다.



**Red Black Tree**

RBT(Red-Black Tree)는 위에서 설명한 Rebalancing기법의 하나로, 기존 이진탐색트리의 삽입, 삭제, 탐색의 비효율성을 개선한 방법이다. RBT는 다음과 같은 규칙을 따른다.







각 노드는 Red 혹은 Black이라는 색깔을 갖는다.

루트 노드는 Black이다.

각 말단 노드(NIL)는 Black이다.

어떤 노드의 색이 Red라면, 두 자식 노드의 색은 모두 Black이다.

어느 한 노드로부터 리프노드(NIL)까지의 Black의 수는 리프노드를 제외하면 모두 같다(이를 Black-Height라 한다).

RBT 특징으로는 다음과 같다.



Binary Search Tree이므로, BST의 특징을 모두 갖고있다.

루트로부터 말단 노드까지의 최소 경로는 최대 경로의 두 배보다 크지 않다. 이를 Balanced한 상태라 한다.

노드의 Child가 없을 경우, Child를 가리키는 포인터에 NIL(혹은 NULL)값을 저장한다. 이러한 NIL 노드들을 말단 노드로 간주한다. 말단 노드이기 때문에, 이 노드들의 색은 Black이다.

RBT에서의 삽입 과정은 다음과 같다. 우선 새로 삽입한 노드를 BST 특성을 유지하며 삽입한 후, 색을 Red로 칠한다. 이는 Black-Height의 수를 최대한 유지하기 위해서이다. 삽입 결과 RBT 특성이 위배된다면, 노드의 색을 다시 칠한다. 만일 Black-Height특성, 즉 위의 5번 규칙이 위배되었다면, Rotation을 통해 조정한다.



삭제 과정 역시 마찬가지로 우선 BST 특성을 유지하며 노드를 삭제한다. 삭제될 노드의 Child와 색깔로 Rotation 방법이 정해진다(후에 삭제 과정을 자세히 조사하겠다).



















**Binary Heap**

Binary Heap은 배열에 기반한 완전 이진탐색트리이며, Max-Heap과 Min-Heap이 있다. Max-Heap은 상위 노드의 값이 하위 각 노드의 값보다 크며, Min-Heap은 반대로 상위 노드의 값이 하위 각 노드의 값보다 작다(형제 노드끼리는 상관없다). 이 성질을 이용하면 최대, 최솟값을 찾아내는 것이 훨씬 용이하다.



![image-20200927230746443](/Users/jh/Library/Application Support/typora-user-images/image-20200927230746443.png)

**HashTable**

HashTable은 내부적으로 배열을 사용하며, 평균적으로 빠른 탐색속도(O(1))를 갖는다. 평균적으로라는 의미는 충돌을 고려하지 않았을 때이다. Key값을 해시함수를 통하여 인덱스로 변환 후에, 그 인덱스에 집어 넣는다. 만약 다른 Key값을 해시함수를 통과시켰는데 같은 인덱스가 나온다면, 그걸 충돌이라고 한다.

충돌 해소법(Resolve Conflict) 방법에는 기본적인 두 가지 방법이 있다.



Open Address 방식 (개방 주소법)

충돌 발생 시, 다른 인덱스를 찾는다.

Linear Probing : 순차적으로 탐색하여 다음 인덱스를 찾는다.

Quadratic Probing : 2차 함수를 이용해 탐색할 위치를 찾는다.

Double Hashing Probing : 충돌 발생시 새로운 해시함수를 활용하여 주소를 찾는다.

Separate Chaining 방식 (분리 연결법)

충돌 발생 시 다른 인덱스를 찾는 대신, 그 인덱스에다가 연결하는 방법.

연결 리스트를 이용하여 연결하는 방법과, Tree(RBT)를 이용하여 연결하는 방법이 있다. 두 방식 모두 Worst Case가 O(M)이다. 데이터의 크기가 크다면 Separate Chaining, 아니라면 Open Address 방식이 더 낫다.

Hashmap의 Resize : 일정 개수이상 크기가 커지면, 해시 버킷의 크기를 두 배로 늘림.

**Graph**

정점과 간선의 집합이며, 일종의 Tree이다.



Undirected와 Directed Graph가 있는데, 방향성 유무로 결정된다.



Degree란 Undirectd Graph에서 정점에 연결된 간선의 개수이다. Directed Graph에서의 Degree는 방향성이 있기 때문에 둘로 나뉘는데, 나가는 간선의 개수는 Outdegree, 들어오는 간선의 개수를 Indegree라 한다.



가중치 그래프 란 간선에 가중치를 둔 그래프, 부분 그래프 란 한 그래프의 일부 정점 및 간선으로 이루어진 그래프.



그래프의 구현 방법 :



인접 행렬 : 정방 행렬을 사용하여 구현. 연결 관계를 O(1)로 파악 가능. 공간 복잡도는 O(2V)

인접 리스트 : 리스트를 사용하여 구현. 정점간 연결 여부 파악애 오래 걸림. 공간 복잡도는 O(E + V)

탐색 방법에는 깊이 우선 탐색(DFS, Depth First Search)와 너비 우선 탐색(BFS, Breadth First Search)이 있다.

깊이 우선 탐색은 말 그대로 깊숙히 들어가서 탐색하고 나오는 것이며, 유용한 자료구조는 Stack이다.

너비 우선 탐색은 임의의 한 정점에 대해 인접한 정점을 queue에 넣고(enqueue), dequeue연산에서 나온 하나의 정점으로 들어가서 그 정점의 인접한 정점을 다시 Queue에 넣어서 탐색하는 방식. BFS로 찾은 경로는 최단 경로이다.





**단순 연결리스트와 이중 연결리스트**



•연결리스트는ﾠ동적배열과ﾠ같이ﾠ같은ﾠ타입의ﾠ데이터ﾠ여러ﾠ개를ﾠ저장ﾠ할ﾠ수ﾠ있는ﾠ가변ﾠ크기를ﾠ가지는ﾠ자료구조이다. 하지만ﾠ동적배열과ﾠ달리ﾠ연결리스트는ﾠ요소들이ﾠ링크에ﾠ의해ﾠ논리적으로ﾠ연결되어있어ﾠ링크를ﾠ따라가면ﾠ이전, 이후ﾠ요소들을ﾠ찾을ﾠ수ﾠ있다.



•이러한ﾠ특징ﾠ때문에ﾠ삽입, 삭제를ﾠ할ﾠ때도ﾠ물리적인ﾠ메모리ﾠ이동없이ﾠ요소간의ﾠ링크만ﾠ조작하면ﾠ되므로ﾠ동적배열에ﾠ비해ﾠ속도가ﾠ빠르다는ﾠ차이점이ﾠ있다.



•배열의ﾠ요소ﾠ하나는ﾠ자신이ﾠ기억할ﾠ데이터ﾠ값만을ﾠ가지는데에ﾠ비해ﾠ연결리스트의ﾠ요소인ﾠ노드는ﾠ데이터ﾠ외에ﾠ연결상태에ﾠ대한ﾠ정보인ﾠ링크를ﾠ추가로ﾠ가져야한다.



•자기ﾠ다음의ﾠ요소가ﾠ누구인지를ﾠ스스로ﾠ기억하고ﾠ있어야ﾠ흩어져ﾠ있는ﾠ노드들의ﾠ순서를ﾠ알ﾠ수ﾠ있는데ﾠ이ﾠ연결정보를ﾠ저장하는ﾠ것이ﾠ바로ﾠ링크이다.



•이때, 링크ﾠ하나만ﾠ가지는ﾠ것을ﾠ단순ﾠ연결리스트라고하고ﾠ두ﾠ개의ﾠ링크를ﾠ가지는ﾠ것을ﾠ이중ﾠ연결리스트라고ﾠ한다.



•노드를ﾠ구성하는ﾠ데이터와ﾠ링크는ﾠ타입이ﾠ다르기ﾠ때문에ﾠ노드는ﾠ이형ﾠ타입의ﾠ집합인ﾠ구조체로ﾠ정의한다.



•	구조체로ﾠ정의한ﾠ노드

**struct** **Node**{

  **int** value;  // 데이터

  Node *next;  // 링크

};

•Value 멤버는ﾠ노드가ﾠ기억하는ﾠ정보의ﾠ실체인ﾠ데이터이다. 배열ﾠ요소ﾠ타입에ﾠ제한이ﾠ없는ﾠ것처럼ﾠ연결리스트가ﾠ저장하는ﾠ정보의ﾠ종류에도ﾠ제한이ﾠ없으므로ﾠ노드의ﾠ데이터는ﾠ임의타입, 임의개수로ﾠ정의ﾠ할ﾠ수ﾠ있다. 



•여러개의ﾠ변수들을ﾠ한꺼번에ﾠ가질수도ﾠ있고ﾠ포인터나ﾠ배열ﾠ또는ﾠ다른ﾠ구조체를ﾠ노드에ﾠ포함시키는ﾠ것도ﾠ물론ﾠ가능하다. 위ﾠ예제ﾠ코드에서는ﾠ편의상ﾠ정수값ﾠ하나만을ﾠ노드에ﾠ포함시켰다. 

•Next 멤버는ﾠ다음ﾠ노드에ﾠ대한ﾠ포인터를ﾠ가지는ﾠ링크이다NNode 구조체안에ﾠ다른Node 구조체의ﾠ번지ﾠ정보가ﾠ포함되어ﾠ있는데ﾠ자신에ﾠ대한ﾠ포인터를ﾠ멤버로ﾠ가지는ﾠ가지ﾠ참조ﾠ

구조체이므로ﾠ무한대가ﾠ되지는ﾠ않는다. 

















**Vector와 List의 차이점**





•Vector는ﾠ요소들이ﾠ인접해ﾠ있으므로ﾠ임의ﾠ접근이ﾠ가능하지만,list는ﾠ노드가ﾠ흩어져ﾠ있으므로ﾠ양방향으로만ﾠ이동이ﾠ가능히다. 이는 +n 연산을ﾠ반복자가ﾠ지원하지ﾠ않으므로ﾠ순서ﾠ값으로ﾠ요소를ﾠ엑세스하는 [n]연산자를ﾠ지원하지ﾠ않으며,쟞t함수도ﾠ당연히ﾠ지원하지ﾠ않는다.



•List는ﾠ임의ﾠ위치를ﾠ상수ﾠ시간내에ﾠ엑세스ﾠ할ﾠ수ﾠ없으며ﾠ반드시ﾠ순회를ﾠ해야만ﾠ원하는ﾠ요소를ﾠ찾을ﾠ수ﾠ있다. 임의접근ﾠ방복자를ﾠ요구하는sort나binary_search 알고리즘은list에서ﾠ사용할ﾠ수ﾠ없다.

•삽입ﾠ삭제ﾠ속도



•List는ﾠ각ﾠ요소들이ﾠ노드로ﾠ할당되어ﾠ링크에ﾠ의해ﾠ연결이ﾠ되어ﾠ있으므로ﾠ삽입ﾠ삭제시ﾠ링크만ﾠ조작해주면ﾠ된다. 요소들이ﾠ흩어져있다ﾠ하더라도ﾠ삽입, 삭제시에ﾠ메모리ﾠ이동을ﾠ할ﾠ필요가ﾠ없으므로ﾠ어느ﾠ위치에서든ﾠ상수ﾠ시간내에ﾠ삽입, 삭제가ﾠ가능하다. 



•이에ﾠ비해ﾠ벡터는ﾠ중간에서ﾠ삽입,삭제할ﾠ때ﾠ데이터를ﾠ밀고ﾠ당겨야ﾠ하므로ﾠ속도가ﾠ다소ﾠ느리다.



•결론은ﾠ구조와ﾠ링크방식의ﾠ차이점에ﾠ기인한다. 읽기ﾠ속도가ﾠ중요하다면ﾠ벡터를ﾠ선택하는ﾠ것이ﾠ좋고, 삽입ﾠ삭제가ﾠ아주ﾠ빈번하다면ﾠ리스트가ﾠ더ﾠ나은ﾠ선택이다.