## **HTTP GET/POST** **비교**

​    

**HTTP (Hyper Text Transfer Protocol)**

\- HTTP는 인터넷상에서 데이터를 주고 받기 위해 서버/클라이언트 모델을 따르는 프로토콜 이다.OSI 7Layer에서 Application 계층에 속하고 TCP/IP 위에서 동작한다.

\- 일반적으로 80번 포트를 통해서 클라이언트가 서버에 요청을 보낸다.

​    

**HTTP** **특징** **Connectless & Stateless**

 HTTP 는 Connectless 방식으로 동작

\- 서버에 연결하고, 요청해서 응답을 받으면 연결을 끊는다.(자원 하나에 하나의 연결)

\- 불특정 다수를 대상으로 하는 서비스에 적합한 방식.

\- 연결을 끊어버리기 때문에, 클라이언트의 이전 상태를 알 수 없다.

\- 이전에 로그인을 했더라도, 다시 들어가면 로그인 상태를 알 수 없음

\- HTTP Cookie개념 등장

​    

​    

​    

​    

​    

#### **HTTP Method**

​    

​    

**GET**

\- 요청하는 데이터를 HTTP Request Message의 Header부분의 URI에 담아서 전송한다. URI라는 공간에 담겨서 데이터를 전송하기때문에 데이터 크기가 제한적이고, 보안이 필요한 데이터를 그대로 전송하면 URI에 노출된다.

\- GET은 Request를 할 때, 필요한 데이터를 쿼리 스트링에 담아서 전송한다.

\- 쿼리 스트링 이란, URL의 끝에 ? 다음으로 Key와 Value로 이루워진 파라미터를 의미한다. 다양한 파라미터를 전송하기 위해서는 &로 연결하면 된다.

\- 서버에서 어떤 데이터를 가져와서 보여주는 행위를 의미

\- 서버 데이터나 상태를 변경하는 행위는 하지 않는다.

\- GET요청은 브라우저에서 캐싱할 수 있다. 따라서, 데이터 크기가 작고 보안이슈가 없다고 GET요청을 보내면 기존에 캐싱된 데이터가 응답할 가능성이 있다.

​    

​    

​    

​    

​    

**POST**

\- GET방식의 query string과 달리 글자 수 제약 없고 파일 업로드 등의 동작이 가능하다.

\- HTTP Message의 Body에 데이터를 담아서 전송한다. 전송할 수 있는 데이터의 크기가 GET방식보다 크고 보안면에서 상대적으로 좋다.(암호화 하지 않는 이상 큰 차이는 없다.)

\- ssl이용하는 https가 아닌경우 uri의 쿼리스트링에 데이터를 담아도 평문이고, body에 데이터를 담아도 평문으로 전송되기 때문에 특별이 뛰어나다고 할 수 없다.

\- 서버의 상태나 값을 변경하거나 추가하는데 사용한다.

​    

**PUT**

\- POST와 달리, 멱등성을 가지고있다.

\- post연산의 경우 리소스를 추가하는 연산이기 때문에, 멱등하지 않지만, put은 반복 수행해도 멱등하다.

\- POST와 달리 클라이언트가 이미 변경 대상 리소스의 위치를 알고 있어서, 대상 리소스를 갱신할 수 있다.(리소스 결정권이 클라이언트에게 있다.)

​    

**DELETE**

\- 자원을 삭제할 것을 요청

\- 특정 자원에 대한 DELETE의 경우 자원을 더 이상 이용할 수 없어야 하므로 ,DELETE요청을 다시 호출한 경우도 자원은 여전히 사용할 수 없는 상태여야 한다.

​    

**GET / POST** **근본적인 의미 차이**

\- GET은 idempotent(멱등), POST는 non-idempotent하다.

\- idempotent(멱등)은 수학용어로 해당 연산을 해도 결과에 변화가 없다는 특성을 표현한다.

\- (100 * 1 = 100 이므로 곱셈에대해 1을 멱등원 이라하고, 1을 곱하는 연산이 멱등 연산)

\- GET은 해당 요청을 몇번을 수행해도 요청에 대한 결과가 계속 동일하게 돌아오는 것을 의미

\- POST는 해당 요청이 수행되면 서버에서 무언가가 변경되고, 동일한 결과가 돌아오는 것을 보장할 수 없음을 의미

\- GET을 이용해서 게시판 업로드 기능을 요청한다면, 멱등성 성질을 무시하고 문제 발생 여지가 있다.

​    

​    

​    

​    

​    

​    

​    

​    

**잘못된 사용**

\- 게시글 업로드 요청인데 GET으로 데이터를 전송하면, 해당 GET요청과 그에 대한 응답이 브라우저에 의해 캐싱되었다가 다시 사용될 우려가 있다.

\- 브라우저 캐시에 의해 자동으로 동일한 글이 서버에 전송되서 같은글이 업로드될 수 있다.

​    

**google accelerator****사건**

​    

\- 사용자가 웹페이지에 접근했을때, accelerator가 모든 url을 클릭해서 브라우저 캐싱처리함

\- URL에는 GET/POST를 용도에 맞지않게 사용해서 (GET인데 삭제를 하는 행위가 포함되는등) 의도치 않게 데이터가 삭제되는 일이 발생

​    

**Server - Client Model**

\- 서비스 제공자, 서비스 요청자로 구분되는 네트워크 모델이다.

\- 제공자역할을 서버, 요청자 역할을 클라이언트라고 한다.

\- 서버/클라이언트 모델에서 모든 자원은 서버에 집중된다.

\- 다수의 클라이언트 요청을 처리하기 위해서 고성능 컴퓨터를 사용

\- 클라이언트는 데이터 presentation을 위해 최소한의 자원을 가지는게 일반적이다.

​    

**장점**

서버/클라이언트 역할이 분리된다

\- 프리젠테이션 영역과 데이터 처리 영역이 분리됨을 의미

데이터가 서버에 집중되므로 보안 유지 상대적으로 쉽다.

​    

**단점**

서버에 네트워크 트래픽과 데이터가 집중된다.

\- 클라이언트 접속수가 많아지면 처리 비용이 증가한다.